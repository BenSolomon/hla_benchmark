---
title: "HLA allele multiple sequence alignment"
output: 
  html_notebook:
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: hide
---

```{r, message = F}
# library(msa)
library(DECIPHER)
library(vegan)
library(tidyverse)
library(cowplot)
```

# HLA sequence alignment

### Load HLA reference sequences
```{r}
fas <- "/labs/khatrilab/solomonb/references/IMGTHLA/hla_nuc.fasta"
seqs <- readDNAStringSet(fas)
seqs
```
### Find all HLA exon sequences
```{r}
imgt_path = "/labs/khatrilab/solomonb/references/IMGTHLA/alignments"
hla_alignments <- tibble(loci = c("A","B","C","DPA1","DPB1","DQA1", "DQB1", "DRB")) %>% 
  mutate(sequences = map(loci, function(x) tibble(lines = read_lines(sprintf("%s/%s_nuc.txt", imgt_path, x))))) %>% 
  mutate(loci = gsub("DRB", "DRB1", loci))
  
parse_exons <- function(df, loci){
  df %>% 
  mutate(lines = trimws(lines, which = "left")) %>% 
  filter(grepl(sprintf("^%s\\*", loci), lines)) %>% 
  separate(lines, into = c("allele", "sequence"), sep = " ", extra = "merge") %>% 
  filter(allele == .$allele[1]) %>% 
  mutate(sequence = gsub("\\.| ", "",sequence)) %>% 
  group_by(allele) %>% 
  summarise(sequence = paste(c(sequence), collapse = "")) %>% 
  mutate(sequence = str_split(sequence, "\\|")) %>% 
  unnest(sequence) %>% 
  mutate(exon = 1:n()) %>% 
  select(exon, sequence)
}

hla_exons <- hla_alignments %>% 
  mutate(sequences = map2(sequences, loci, parse_exons))
```

### Function to convert exon dataframe to a DNAstringset

```{r}
exon_df_to_set <- function(df){
  exons <- df %>%
    column_to_rownames("exon") %>%
    pull(sequence) %>%
    DNAStringSet() %>%
    .[1:length(.) - 1]
  names(exons) <-
    paste("Exon_", 1:length(exons), sep = "")
  return(exons)
}

exon_df_to_set(hla_exons$sequences[[1]])
```

### Function to filter HLA references sequences

- Start/stop codons
    - Currently inactive
    - Might consider removing the start/stop codon requirement if mismatches arent included as a possible nucleotide state for shannon
- Unique sequences
- Don't have an expression suffix (N, Q, L, S, C, A)

```{r, message=F, warning=F, error=F}
sequence_filter <- function(sequences){
  allele_ids <- tibble(id = names(sequences)) %>% 
    separate(id, into = c("id","allele", "length"), sep = " ", extra = "merge") %>% 
    mutate(valid_allele = !grepl(pattern = "[A-Z]$",allele))
  sequences[(subseq(sequences, 1, 3) == "ATG") &
            # (grepl(pattern = "TGA|TAA|TAG", subseq(sequences, -3, -1))) &
            allele_ids$valid_allele]
  }
# hlaA <- seqs[grepl(" A\\*", names(seqs))] %>% sequence_filter() %>% unique() %>% AlignSeqs()
# hlaB <- seqs[grepl(" B\\*", names(seqs))] %>% sequence_filter() %>% unique() %>% AlignSeqs()
# hlaC <- seqs[grepl(" C\\*", names(seqs))] %>% sequence_filter() %>% unique() %>% AlignSeqs()
# hlaDPA1 <- seqs[grepl(" DPA1\\*", names(seqs))] %>% sequence_filter() %>% unique() %>% AlignSeqs()
# hlaDPB1 <- seqs[grepl(" DPB1\\*", names(seqs))] %>% sequence_filter() %>% unique() %>% AlignSeqs()
# hlaDQA1 <- seqs[grepl(" DQA1\\*", names(seqs))] %>% sequence_filter() %>% unique() %>% AlignSeqs()
# hlaDQB1 <- seqs[grepl(" DQB1\\*", names(seqs))] %>% sequence_filter() %>% unique() %>% AlignSeqs()
# hlaDRB1 <- seqs[grepl(" DRB1\\*", names(seqs))] %>% sequence_filter() %>% unique() %>% AlignSeqs()
```


### Create HLA sequence sets with valid alleles and exon scaffold
```{r}
hla_sequences <- hla_exons %>% 
  mutate(exons = sequences) %>% 
  mutate(exons = map(exons, exon_df_to_set)) %>% 
  mutate(sequences = map(loci, function(x) seqs[grepl(sprintf(" %s\\*", x), names(seqs))])) %>% 
  mutate(sequences = map(sequences, function(x) x %>% sequence_filter() %>% unique())) %>% 
  mutate(sequences = map2(sequences, exons, function(x,y) append(x,y)))
hla_sequences$sequences[[8]]
```
### Align sequences
```{r, message=F}
hla_aligned <- hla_sequences %>% 
  mutate(alignment = map(sequences, AlignSeqs))
```

### Find exon positions in alignment
```{r}
hla_match <- hla_aligned %>%
  filter(loci != "DQB1") %>% #Filtered because of database inconsistencies with exon 5
  mutate(ranges = map2(alignment, exons,  function(a,e){
    lapply(e, function(x) matchPattern(pattern = subseq(x, -20, -1), subject = a[[1]], with.indels = T))
    # lapply(e, function(x) print(x))
    }))

get_exon_ranges <- function(match_output, allele_length) {
  exon_df <- tibble(range = lapply(match_output, function(x)
    as.data.frame(x@ranges))) %>%
    mutate(exon = 1:n()) %>%
    unnest(range) %>% 
    mutate(start = lag(end, default = 0) + 1) %>% 
    select(exon, start, end)
  
  bind_rows(
    exon_df,
    tribble( ~start, ~ end, max(exon_df$end), allele_length) %>%
      mutate(
        exon = max(exon_df$exon + 1)
      )
  ) %>% 
  rowwise() %>% 
  mutate(center = round(mean(c(start, end))))
}

hla_match <- hla_match %>% 
  mutate(bp = map_dbl(alignment, function(x) max(sapply(x, nchar)))) %>% 
  mutate(ranges = map2(ranges, bp, get_exon_ranges))
```

### Convert alignment positions to nucleotide tallies
```{r}
position_tally <- function(alignment){
  as.tibble(as.matrix(alignment)) %>% 
  pivot_longer(cols = everything(), names_to = "position", values_to = "nucleotide") %>% 
  group_by(position) %>% 
  count(nucleotide) %>% 
  pivot_wider(names_from = "position", values_from = "n", values_fill = 0) %>% 
  filter(grepl("[ACGT]", nucleotide)) %>% 
  column_to_rownames("nucleotide")
}

hla_tally <- hla_match %>% 
  mutate(tally = map(alignment, function(x){
    x[!grepl("Exon", names(x))] %>% 
      position_tally()
    }))
```

### Calculate shannon entropy by position
```{r}
position_shannon <- function(tally){
  diversity(tally, MARGIN = 2, base = 2) %>% 
  enframe(name = "position", value = "shannon") %>% 
  mutate(position = as.numeric(gsub("V", "", position))) %>% 
  arrange(position)
}

hla_entropy <- hla_tally %>% 
  mutate(entropy = map(tally, position_shannon))

# saveRDS(hla_entropy, "/labs/khatrilab/solomonb/hla_project/hla_benchmark/hla_sequence_entropy_includeIncomplete.RDS")
```

```{r}
## Version where only sequences with all exons included
# hla_entropy <- readRDS("/labs/khatrilab/solomonb/hla_project/hla_benchmark/hla_sequence_entropy.RDS")
## Version where sequences without all exons present included
hla_entropy <- readRDS("/labs/khatrilab/solomonb/hla_project/hla_benchmark/hla_sequence_entropy_includeIncomplete.RDS")
```


### Plot individual loci
```{r, message = F}
gg_align <- function(locus, shannon, exons, length){
  hla_window <-  length*0.1
  plot <- shannon %>% 
    mutate(shannon_roll = zoo::rollmean(shannon, k = round(hla_window), fill = NA)) %>% 
    ggplot(aes(x = position))+
    geom_bar(aes(y=shannon),stat = "identity") +
    geom_path(aes(y=shannon_roll),stat = "identity") +
    theme_bw() +
    ggtitle(locus, subtitle = sprintf("Window: %s", round(hla_window)))+
    coord_cartesian(ylim=c(0,2)) +
    geom_rect(data = exons, aes(xmin = start, xmax = end, ymax = 1.9, ymin = 1.8, x = NULL, y = NULL), color = "black", fill = "white") +
    geom_text(data = exons, aes(x = center, y = 2, label = exon))
  suppressWarnings(print(plot))
}

# gg_align(hla_entropy$loci[[1]], hla_entropy$entropy[[1]], hla_entropy$ranges[[1]], hla_entropy$bp[[1]])

hla_entropy %>% 
  mutate(plot = pmap(list(loci, entropy, ranges, bp), gg_align))
```
### Plot heatmap of mean entropy
```{r, fig.width=12, fig.height = 4, message = F}
step <- 50
hla_entropy %>% 
  select(loci, entropy) %>% 
  unnest(entropy) %>% 
  mutate(bp = floor(position/step)*step) %>% 
  group_by(loci, bp) %>% 
  summarise(average_shannon = mean(shannon)) %>% 
  ggplot(aes(x = bp, y = loci, fill = average_shannon))+
  geom_tile() +
  theme_bw() +
  scale_fill_viridis_c()
```
### Plot rolling mean entropy
```{r}
gg_combo_entropy <- function(df, grouping_var){
  grouping_var <- enquo(grouping_var)
  df <- df %>% 
    mutate(grouping = !!grouping_var) %>% 
    group_by(grouping) %>% 
    nest() %>% 
    mutate(layer = map(data, function(x) list(
      geom_path(data = x, stat = "identity", size = 2, aes(group = loci), color = "black"),
      geom_path(data = x, stat = "identity", size = 1.5)
  )))
  ggplot(df, aes(x = position, y = shannon_roll, color = loci)) + 
    df$layer +
    theme_bw()+
    scale_color_brewer(palette = "Set2") +
    labs(y = "Shannon entropy", color = "Loci") 
}
```


```{r, fig.width=12, fig.height = 4}
step <- 100
p5_plot <- hla_entropy %>% 
  select(loci, entropy) %>% 
  unnest(entropy) %>% 
  group_by(loci) %>% 
  # mutate(shannon_roll = zoo::rollmean(shannon, k = step, fill = NA)) %>% 
  mutate(shannon_roll = zoo::rollapply(shannon, width = step, mean, partial = T)) %>% 
  arrange(position) %>% 
  gg_combo_entropy(., loci) +
  labs(x = "Position from 5' (bp)") 

p3_plot <- hla_entropy %>% 
  select(loci, entropy) %>% 
  unnest(entropy) %>% 
  group_by(loci) %>% 
  # mutate(shannon_roll = zoo::rollmean(shannon, k = step, fill = NA)) %>% 
  mutate(shannon_roll = zoo::rollapply(shannon, width = step, mean, partial = T)) %>% 
  mutate(position = max(position) - position) %>% 
  # mutate(position = position - max(position)) %>% 
  arrange(position) %>% 
  gg_combo_entropy(., loci) +
  # scale_x_reverse()+
  labs(x = "Position from 3' (bp)") 
```

```{r, fig.width=12, fig.height = 8}
plot_grid(
  p5_plot,
  p3_plot,
  ncol = 1,
  labels = c("A","B")
)
```

# RNA seq alignment efficiency

- Accuracy of 3p HLA genotyping is similar to 5p based sequencing despite relatively less sequence information inherent in 3p end of transcript
- Perhaps sequences that get mapped are equally good at resulting in predictions, but overall mapping efficiency is reduced in 3p based sequencing

### Function to extract mapping data

- Adapted from function used in 3_coverage

```{r, message = F}
hla_mapping_stats_import_v2 <- function(samples, log_dir){
  tibble(sample = samples) %>% 
    mutate(data = map(sample, function(x){
      log_path <- sprintf("%s/%s.genotype.log",log_dir,x)
      df <- tibble(lines = read_lines(log_path))
      if (any(grepl("error", df$lines, ignore.case = T))){
        NA
      } else {
        total_reads <- df %>% 
          mutate(lines = gsub("\t", "", lines)) %>% 
          filter(grepl("^\\[alignment\\] Processed", lines)) %>%
          mutate(lines = gsub("\\,.*", "", lines)) %>% 
          mutate(lines = str_extract(lines, "[0-9]+")) %>% 
          pull(lines) %>% 
          as.numeric()
        df %>% 
          mutate(lines = gsub("\t", "", lines)) %>% 
          filter(grepl("^HLA", lines)) %>% 
          separate(lines, into = c("locus", "abundance", "reads", "classes"), sep = " +") %>% 
          mutate(total_reads = total_reads) %>% 
          mutate(total_hla_reads = sum(as.numeric(reads)))
      }
    })) %>%
    unnest(data) %>% 
    select(!(contains("data"))) %>% 
    separate(locus, into = c(NA, "locus"), sep = "-") %>% 
    mutate_at(c("reads", "classes"), as.numeric)
}

isb_path <- "/labs/khatrilab/solomonb/covid/isb"
isb_samples <- read_tsv("/labs/khatrilab/solomonb/covid/isb/logs/210217_232725/parallel.log") %>% 
  separate(Command, into = c(NA, "sample"), sep = " ") %>% 
  pull(sample) %>% unique()
arcas_log_dir <- sprintf("%s/arcasHLA", isb_path)

pmid_path <- "/labs/khatrilab/solomonb/covid/pmid30518681/scRNA"
pmid_samples <- read_tsv(sprintf("%s/sc_sra_accession.txt", pmid_path), col_names = "sample") %>% pull(sample)
```

### Calculate mapping efficiency 
```{r}
p5_mapping <- hla_mapping_stats_import_v2(isb_samples, arcas_log_dir) %>% 
  filter(grepl("^[ABC]|^D[PQR][AB]1", locus) & grepl("-(AC|BL)$", sample)) %>% 
  mutate(alignment_efficiency = reads / total_reads) 

p3_mapping <- hla_mapping_stats_import_v2(pmid_samples, sprintf("%s/arcasHLA", pmid_path)) %>% 
  filter(grepl("^[ABC]|^D[PQR][AB]1", locus)) %>% 
  mutate(alignment_efficiency = reads / total_reads) 
```

### Plot mapping efficiency
```{r, fig.width = 10, fig.heigh = 4}
map_plot <- tibble(orientation = fct_inorder(c("5p", "3p")),
       data = list(p5_mapping, p3_mapping)) %>%
  unnest(data) %>%
  mutate(alignment_efficiency = 100 * alignment_efficiency) %>%
  ggplot(aes(x = locus, y = alignment_efficiency, fill = orientation)) +
  stat_summary(
    fun = mean,
    position = "dodge",
    geom = "bar",
    color = "black"
  ) +
  stat_summary(
    fun.data = mean_se,
    position = position_dodge(width = 0.9),
    geom = "errorbar",
    width = 0.5
  ) +
  theme_bw() +
  scale_y_sqrt(labels = c(0.01, 0.5, 1.0, 1.5),
               breaks = c(0.01, 0.5, 1.0, 1.5)) +
  # ggbreak::scale_y_break(c(0.05, 0.25), scales = 4) +
  scale_fill_grey(start = 1, end = 0.5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "Mapping efficiency", fill = "Orientation", x = "")
map_plot

tibble(orientation = fct_inorder(c("5p", "3p")),
       data = list(p5_mapping, p3_mapping)) %>%
  unnest(data) %>%
  mutate(alignment_efficiency = 100 * alignment_efficiency) %>%
  ggplot(aes(x = locus, y = alignment_efficiency)) +
  stat_summary(
    fun = mean,
    position = "dodge",
    geom = "bar",
    color = "black",
    fill = "grey50"
  ) +
  stat_summary(
    fun.data = mean_se,
    position = position_dodge(width = 0.9),
    geom = "errorbar",
    width = 0.5
  ) +
  facet_wrap( ~ orientation, scales = "free") +
  theme_bw() +
  labs(y = "Mapping efficiency", fill = "Orientation", x = "")
```
### Plot relative mapping efficiency

```{r, message = F, warning = F}
rel_map_plot <- tibble(orientation = c("5p", "3p"),
       data = list(p5_mapping, p3_mapping)) %>%
  unnest(data) %>%
  group_by(orientation, locus) %>%
  summarise(
    alignment_efficiency_mean = mean(alignment_efficiency),
    alignment_efficiency_se = sd(alignment_efficiency) / sqrt(n()),
    n = n()
  ) %>%
  select(-n, -alignment_efficiency_se) %>%
  pivot_wider(names_from = "orientation", values_from = "alignment_efficiency_mean") %>%
  mutate(relative_efficiency = `5p` / `3p`) %>%
  ggplot(aes(x = locus, y = relative_efficiency)) +
  geom_bar(stat = "identity", color = "black", fill = "grey50") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "Relative mapping efficiency (5p / 3p )", x = "")
rel_map_plot
```

# Final plot

```{r, fig.width = 12, fig.height = 8}
plot_grid(
  p5_plot,
  map_plot,
  p3_plot,
  rel_map_plot,
  nrow = 2,
  ncol = 2,
  align = "hv",
  axis = "lrtb",
  rel_widths = c(2,1),
  labels = c("A","C","B","D")
)
```

# Old work

```{r, fig.width = 6, fig.heigh = 4}
bulk_path <- "/labs/khatrilab/solomonb/covid/pmid30518681/bulkRNA"
bulk_samples <- read_tsv(sprintf("%s/bulk_sra_accession.txt", bulk_path), col_names = "sample") %>% pull(sample)

bulk_mapping <- hla_mapping_stats_import_v2(bulk_samples, sprintf("%s/arcasHLA", bulk_path)) %>% 
  filter(grepl("^[ABC]|^D[PQR][AB]1", locus)) %>% 
  mutate(alignment_efficiency = reads / total_reads) 

tibble(orientation = c("Bulk", "5p", "3p"), data = list(bulk_mapping, p5_mapping, p3_mapping)) %>%
  unnest(data) %>%
  mutate(alignment_efficiency = 100 * alignment_efficiency) %>%
  ggplot(aes(x = locus, y = alignment_efficiency, fill = orientation)) +
  stat_summary(
    fun = mean,
    position = "dodge",
    geom = "bar",
    color = "black"
  ) +
  stat_summary(
    fun.data = mean_se,
    position = position_dodge(width = 0.9),
    geom = "errorbar",
    width = 0.5
  ) +
  theme_bw() +
  scale_y_sqrt(labels = c(0.01, 0.5, 1.0, 1.5),
               breaks = c(0.01, 0.5, 1.0, 1.5)) +
  # ggbreak::scale_y_break(c(0.05, 0.25), scales = 4) +
  scale_fill_grey(start = 1, end = 0.5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "Mapping efficiency", fill = "Orientation", x = "")

```


```{r}
lapply(hlaA_patterns, function(x) matchPattern(pattern = x, subject = chartr("-", "N", hlaA[[1]]), with.indels = T, fixed = T))

matchPDict(pdict = hlaA_patterns, subject = chartr("-", "N", hlaA[[1]]), with.indels = T)

hlaA
names(hlaA)
matchPattern(DNAString("CAGACCTGGGCG"), hlaA[[1]], with.indels = T, fixed = F)
matchPattern(DNAString("CAGACCTGGGCG"), chartr("-", "N", hlaA[[1]]), with.indels = T, fixed = F)

chartr("-", "N", hlaA[1:2])

subseq(hlaA[1], 67, 90)
```

```{r}
hlaA_exon_set  <- hla_exons$sequences[[1]] %>% 
  column_to_rownames("exon") %>% 
  pull(sequence) %>% 
  DNAStringSet() %>% 
  .[1:length(.)-1]
names(hlaA_exon_set) <- paste("Exon_",1:length(hlaA_exon_set), sep="")
names(hlaA_exon_set)

hlaA <- seqs[grepl(" A\\*", names(seqs))] %>% sequence_filter() %>% unique() %>% append(hlaA_exon_set)

hla_wE <- hlaA %>% AlignSeqs()

hla_wE
lapply(hla_wE[grepl("Exon", names(hla_wE))], as.character)
x <- lapply(hlaA_patterns, function(x) matchPattern(pattern = x, subject = hla_wE[[1]], with.indels = T))
y <- x[[1]]
nchar(hla_wE[[1]])
x
tribble(~start, ~end,
        )

y@ranges %>% as.data.frame()
exon_ranges <- tibble(range = lapply(x, function(y) as.data.frame(y@ranges))) %>% 
  mutate(exon = 1:n()) %>% 
  unnest(range) 
exon_ranges <- bind_rows(
  exon_ranges,
  tribble( ~ start, ~ end, max(exon_ranges$end), nchar(hla_wE[[1]])) %>%
    mutate(
      width = 1 + end - start,
      exon = max(exon_ranges$exon + 1)
    )
)
exon_ranges <- exon_ranges %>% 
  rowwise() %>% 
  mutate(center = round(mean(c(start, end))))
exon_ranges
```


```{r}
BrowseSeqs(hlaA, highlight=0)
```



```{r, fig.width = 12, fig.height = 4, message=F,warning=F}
gg_align <- function(alignment){
diversity(position_tally(alignment), MARGIN = 2, base = 2) %>% 
  enframe(name = "position", value = "shannon") %>% 
  mutate(position = as.numeric(gsub("V", "", position))) %>% 
  arrange(position) %>% 
  {max(.$position)*0.1 ->> hla_window;.} %>% 
  mutate(shannon_roll = zoo::rollmean(shannon, k = round(hla_window), fill = NA)) %>% 
  ggplot(aes(x = position))+
  geom_bar(aes(y=shannon),stat = "identity") +
  geom_path(aes(y=shannon_roll),stat = "identity") +
  theme_bw() +
  ggtitle(deparse(substitute(alignment)), subtitle = sprintf("Window: %s", round(hla_window)))+
  coord_cartesian(ylim=c(0,2))
}
gg_align(hlaA)
gg_align(hlaB)
gg_align(hlaC)
gg_align(hlaDPA1)
gg_align(hlaDPB1)
gg_align(hlaDQA1)
gg_align(hlaDQB1)
gg_align(hlaDRB1)
gg_align(hla_wE) +
  geom_rect(data = exon_ranges, aes(xmin = start, xmax = end, ymax = 2, ymin = 1.8, x = NULL, y = NULL), color = "black", fill = "white") +
  geom_text(data = exon_ranges, aes(x = center, y = 1.9, label = exon))

```

```{r}
```

